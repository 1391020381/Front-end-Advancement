# 早期「假」模块化时代
* 从某种角度上看，闭包简直就是一个天生解决数据访问性问题的方案。通过立即执行函数（IIFE），我们构造一个私有的作用域，再通过闭包，将需要对外暴露的数据和接口输出，我们称此为 IIFE 模式
* 事实上，这就是现代模块化方案的基石。到此为止，我们经历了模块化的第一阶段：「假」模块化时代。
# commonjs
* 文件即模块,文件内所有代码都运行在独立的作用域,因此不会污染全局空间
* 模块可以被多次引用 加载 。在第一次被加载时 会被缓存, 之后都从缓存中直接读取结果
* 加载某个模块,就是引入该模块的 module.exports 属性
* module.exports 属性输出的是值的拷贝 一旦这个值被输出 模块内再发生变化不会影响到输出的值
* 模块加载顺序按照代码引入的顺序

# 规范标准时代 AMD
# 规范标准时代 CMD

* CMD 遵循依赖就近原则 AMD遵循依赖前置原则
# 规范标准时代 UMD
 * 该模式的核心思想在于利用立即执行函数根据环境来判断需要的参数类别


# ES 原生时代和 tree shaking
* ES模块的设计思想是尽量 `静态化`,这样能保证在编译时就确定模块之间的依赖关系,每个模块的输入和输出变量也都是确定的。
* CommonJS和AMD模块无法保证前置即确定这些模块,`只能在运行时确定` 
* CommonJS模块输出的是一个值的拷贝,ES模块输出的是值的引用。


# ES模块化为什么要设计成静态的
* 一个明显的优势是:同构静态分析,我们能够分析出倒入的依赖。如果倒入的模块没有被使用,我们便可以通过 tree shaking 等手段减少代码体积，进而提升运行性能。这就是基于ESM实现tree shaking 的基础。


* 只能在文件顶部import 依赖