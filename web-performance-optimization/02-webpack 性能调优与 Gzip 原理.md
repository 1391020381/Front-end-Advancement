* 从输入url到显示页面这个过程中,涉及到网络层面的,有三个主要过程：
    - DNS解析
    - TCP连接
    - HTTP请求/响应

    * 对于DNS解析和TCP连接两个步骤,我们前端可以做的努力非常有限。HTTP连接这一层面的优化才是我们优化优化的核心。

    * HTTP优化有两个大的方向：
        - 减少请求次数
        - 减少单次请求所话费的时间

    * 这个两个优化指向我们日常开发中非常常见的操作---- 资源的压缩与合并。 就是每天构建工具在做的事情。 即webpack   


    * webpack的性能瓶颈 
        - webpack的构建过程太花时间
        - webpack 打包的结果体积太大


    * exclude 只能作用于loader 不能作用于 webpack 插件 例如 UglifyJsPlugin 

    *  处理第三方库的姿势有很多  推荐使用 DllPlugin 
    * DllPlugin是基于Windows 动态链接库(dll) 的思想被创造出来的。这个插件会把第三方库单独打包到一个文件中,这个文件就是一个单纯的依赖库。这个依赖库不会跟着你的业务代码一起被重新打包, 只是当依赖自身发生版本变化时会重新打包。 


    * 用DllPlugin 处理文件,要分两部走：
        - 基于 dll 专属的配置文件,打包dll库
        - 基于webpack.config.js文件,打包业务代码



  * Happypack - 将loader 由单进程转为多进程  

  * webpack-bundle-analyzer  


  * Tree-Shaking

  * webpack2 原生支持ES6的模块系统 并基于此推出Tree-Shaking 。 
  * Tree-Shaking的针对性非常墙,它更适合用来处理模块级别的冗余代码。基于 颗粒度更细的冗余代码的出除,往往被整合进js css的压缩或分离过程中。

   * 按需加载  
    - 把组件按组分块  const Foo = ()=> import(/* webpackChunkName:'group-foo'*/,'./Foo.vue')  

   * 所谓的按需加载,根本上就是在正确的时机出触发相对应的回调     


   # Gzip压缩原理

   * HTTP压缩是一种内置到网页服务器和网页客户端中以改进传输速度和宽带利用效率的方式。在使用HTTP压缩的情况下,`HTTP数据在从服务器发送前就已压缩`
   兼容的浏览器将在下载所需的格式前宣告支持何种方式给服务器 不支持压缩方法的浏览器将下载未压缩的数据。最常见的压缩方案包括 Gzip Deflate


   * `HTTP压缩就是以缩小体积为目的,对HTTP内容进行重新编码的过程`
   * Gzip的内核就是 Deflate  目前我们压缩文件用的最多的就是Gzip。


   * 具有一定规模的项目文件。实践证明,这种情况下压缩和解压带来的时间开销相对于传输过程中节省下的时间开销来说,可以说是微不足道的。



   * 首先要承认Gzip是高效的,压缩后通常能帮助我们减少响应70%左右的大小。

   * Gzip并不保证针对每个文件的压缩都会使其变小。
   * Gzip压缩背后的原理,是在一个文本文件中找出一些重复出现的字符串 临时替换它们 从而使整个文件变小。根据这个原理,文件中代码的重复率越高,那么压缩的效率就越高,使用Gzip的收益也就越大。反之依然。

  * webpack的Gzip的服务端的Gzip
   