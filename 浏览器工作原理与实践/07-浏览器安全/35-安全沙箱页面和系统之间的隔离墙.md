
* `从稳定性视角来看,单进程架构的浏览器是不稳定的`,因为只要浏览器进程中的任意一个功能出现异常都有可能影响到整个浏览器,比如页面卡死,浏览器崩溃等。
* `浏览器架构是如何影响到操作系统安全的`

* 浏览器本身的漏洞是单进程浏览器的一个主要问题,如果浏览器被爆出存在漏洞,那么黑客有可能通过恶意的页面向浏览器中注入恶意程序,其中最常见的攻击方式是利用 `缓冲区溢出`
* 这种类型的攻击和xss注入的脚本是不一样的。

1. xss攻击只是将恶意的js脚本注入到页面中,虽然能窃取一些Cookie相关的数据,但是XSS无法对操作系统进行攻击。
2. 而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的,可以读取和修改浏览器进程内部的任意内容,还可以穿透浏览器,在用户的操作系统上悄悄地安装恶意软件,监听用户键盘输入信息以及读取用户硬盘上的文件内容。

# 安全视角下的多进程架构

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/浏览器工作原理与实践/note/img/浏览器内核和渲染进程.png)

* 浏览器内核和渲染内核两个核心模块,其中浏览器内核是由网络进程 浏览器主进程和GPU进程组成的,渲染内核就是渲染进程。
* 所有的网络资源都是通过浏览器来下载的,下载后的资源会通过IPC将其提交给渲染进程(浏览器内核和渲染进程之间都是通过IPC来通信的)。然后渲染进程会对这些资源进行解析 绘制等操作,最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上,而是将最终生成的图片提交给浏览器内核模块,由浏览器内核模块负责显示这张图片。

# 安全沙箱
* 渲染进程需要执行DOM 解析 CSS解析 网络图片解码等操作,如果渲染进程中存在漏洞以上操作有可能让恶意站点获取到渲染进程的控制权,进而又获取操纵系统的控制权限。
* 网络资源的内容存在着各种可能性,所以浏览器会默认所有的网络资源都是不可信的 都是不安全的。

* 下载恶意软件,但是没有执行它,那么恶意程序是不会生效的。   `将渲染进程和操作系统隔离的这道墙就是安全沙箱`

* 浏览器中的安全沙箱是利用操作系统提供的安全技术,让渲染进程在执行中无法访问或者修改操作系统中的数据,在渲染进程需要访问系统资源的时候,需要通过浏览器内核来实现，然后将访问的结果通过IPC转发给渲染进程。
* `安全沙箱最小的保护单位是进程。`因为单进程浏览器需要频繁访问或者修改操作系统的数据,所以单进程浏览器是无法被安全沙箱保护的,而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。

# 安全沙箱如何影响各个模块功能。

* 安全沙箱最小的保护单位是进程,并且能限制进程对操作系统资源的访问核修改,这意味如果要让安全沙箱应用在某个进程上,那么这个进程必须没有读写操作系统的功能,比如读写本地文件 发起网络请求 调用GPU接口等。
![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/浏览器工作原理与实践/note/img/浏览器内核和渲染进程各自职责.png)

* 由于渲染进程需要安全沙箱的保护,因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中出实现。
1. 持久存储
* 由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统,但是在渲染进程内部有访问Cookie的需求, 有上传文件的需求,为了解决这些文件的访问需求,所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现,然后通过IPC将操作结果转发给渲染进程。
* 具体地讲,文件的读取都是浏览器内核中完成的:
    - 存储Cookie数据的读写。通常浏览器内核会维护一个存放所有Cookie的Cookie数据库,然后当渲染进程通过js来读取Cookie时,渲染进程会通过IPC将读取Cookie的信息发送给浏览器内核,浏览器内核读取Cookie之后再将内容返回给渲染进程。
    - 一些缓存文件的读写也是由浏览器内核实现的,比如网络文件缓存的读取。
2. 网络访问
* 在渲染进程内部也是不能直接访问网络的,如果要访问网络,则需要通过浏览器内核。不过浏览器内核处理URL请求之前,会检查渲染进程是否有权限请求该url,比如检查XMLHttpRequest或者Fetch是否是跨站点,或者检测HTTPS的站点中是否包含了HTTP的请求。

3. 用户交互
* 渲染进程实现了安全沙箱,还影响了一个非常重要的用户交互功能。
通常情况下,如果你要实现一个UI程序,操纵系统会提供一个界面给你,该界面允许应用程序于用户交互,允许应用程序在该界面上进行绘制,比如Windows提供的是HWND Linux提供的X Window，我们就把HWND 和 X Window通称为窗口句柄。应用程序可以在窗口句柄上进行绘制和接受键盘鼠标消息。
* 现在浏览器中,由于每个浏览器都有安全沙箱的保护,所以在渲染进程内部是无法直接操作窗口句柄的,这也是限制渲染进程监控到用户的输入事件。

* 由于渲染进程不能直接访问 窗口句柄 所以渲染进程需要完成以下两点大的改变。
    - 1. 渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图,渲染进程需要将生成好的位图发送给浏览器内核,然后浏览器内核将位图复制到屏幕上。
    - 2. 操作系统没有将用户输入事件直接传递给渲染进程,而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件,如果当前焦点位于浏览器地址栏中,则输入事件会在浏览器内核内部处理;如果当前焦点在页面的区域内,则浏览器内核会将输入事件转发给渲染进程。

    - 这样就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。
# 站点隔离(Site Isolation)
* 所谓站点隔离是指Chrome将同一站点(包含了相同根域名核相同协议的地址)中相互关联的页面放到同一个渲染进程中执行。

* Chrome最开始划分渲染进程是以标签页位单位,也就是说整个标签页会被划分给某个渲染进程。但是,按照标签页划分渲染进程存在一些问题,原因就是一个标签中可能包含了多个iframe,而这些iframe又有可能来自不同的站点,这就导致多个不同站点中的内容通过iframe同时运行在同一个渲染进程中。

* 目前所有操作系统都面临这两个A级漏洞--- 幽灵（Spectre）和 熔毁(Meltdown) 这两个漏洞是由处理器架构导致的,很难修补。
* 如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。
* 实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。