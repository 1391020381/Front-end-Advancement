* HTTP协议的目的很单纯,就是为了传输超文本文件,那时候也没有太强大的加密传输的数据需求,所以HTTP一直保持着明文传输数据的特征。但这样的话,在传输过程中的每个环节,数据都有可能被窃取或者篡改,这也意味着和服务器之间还有可能有个中间人。
* 我们使用HTTP传输的内容很容易被中间人窃取 伪造和篡改 通常我们把这种攻击方式称为中间人攻击。
![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/浏览器工作原理与实践/note/img/中间人攻击.png)

# 在HTTP协议栈中引入安全层
![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/浏览器工作原理与实践/note/img/HTTP%20VS%20HTTPS.png)
* 安全层有两个主要的职责:对发起HTTP请求的数据进行加密操作和对接受到HTTP内容进行解密操作。

# 第一版:使用对称加密
* 提到加密,最简单的方式是使用对称加密。所谓对称加密是指加密和解密都使用的是相同的秘钥。

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%20HTTPS.png)

* HTTPS首先要协商加解密方式,这个过程就是HTTPS建立安全连接的过程。为了让加密的密钥更加难以破解,我们让服务器和客户端同时决定密钥。
* 这样浏览器和服务端都有相同的client-random和service-random了,然后它们再使用相同的方法将client-random 和 service-random混合起来生成一个密钥master-secret，有了密钥master secret和加密套件之后,双方就可以进行数据的加密传输了。


* client-random sercie-random 传输过程都是明文的,意味着黑客也可以拿到协商的加密套件和双方的随机数,由于利用随机合成密钥的算法是公开的,所以黑客拿到随机数之后,也可以合成密钥,这样数据依然可以破解。

# 第二版:使用非对称加密

* 非对称加密算法有 A B两把密钥,如果你用A密钥来加密,那么只能使用B密钥来解密;反过来,如果你要B密钥来加密,那么只能用A密钥来解密。

* 在HTTPS,服务器会将其中的一个密钥通过明文的形式发送给浏览器,我们把这个密钥称为`公钥`,服务器自己留下的那个密钥称为`私钥` 顾名思义,`公钥是每个人都能获取到的,而私钥只有服务器才能知道,不对任何人公开。`

* 非对称加密的请求流程
1. 首先浏览器还是发送`加密套件列表`给服务器。
2. 然后`服务器会选择一个加密套件`,不过和对称加密不同的是,使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密HTTP数据的私钥,由于公钥是给浏览器加密使用的,因此服务器会将加密套件和公钥一道发送给浏览器。
3. 最后就是浏览器和服务器返回确认消息。


* 这样浏览器就有了服务器的公钥,在浏览器向服务器端发送数据时,就可以使用该公钥来加密数据。私钥只有服务端才有,可以用来解密客户端使用公钥加密的数据。


1. 非对称加密的效率太低
2. 无法保证服务端发送给浏览器的数据安全。

# 对称加密和非对称加密搭配使用
* `在传输数据阶段依然使用对称加密,但是对称加密的秘钥我们采用非对称加密来传输。`
![](https://static001.geekbang.org/resource/image/b5/ac/b5bffdc1dd47cb1fa2180c62ae9c77ac.png)

* 经过上图,服务器和浏览器就有了共同的 client-random  service-random pre-master 然后服务器和浏览器会使用这三组随机数生成 `对称秘钥`,因为服务器和浏览器使用同一套方法来生成秘钥,所以最终生成的秘钥也是相同的。
* pre-master 是经过公钥加密之后传输的,所以黑客无法获取到pre-master,这样黑客就无法生成秘钥,也就保证了黑客无法破解传输过程中的数据了。

# 第四版:添加数字证书
* 通过对称和非对称混合方式,我们完美地实现了数据的加密传输。  
* 黑客通过DNS劫持将 IP地址替换成了黑客的IP地址,这样我们访问的其实是黑客的服务器了,黑客就可以在自己的服务器上实现公钥和私钥,而对浏览器来说,它完全不知道现在访问的是黑客的站点。

![](https://static001.geekbang.org/resource/image/f5/f8/f509dedc99e740e57ff2c9d5cc8478f8.png)

# 数字证书的申请和验证

# 如何申请数字证书
1. 首先申请人需要准备一套私钥和公钥,私钥留着自己使用
2. 然后申请人需要向CA机构提交公钥 公司 站点等信息并等待认证,这个认证过程可能是收费的。
3. CA通过线上、线下等多种渠道来验证申请人所提供信息的真实性,如公司是否存在企业是否合法,域名是否归属该企业等。
4. 如信息审核通过,CA会申请人签发认证的数字证书,包含了申请人的 公钥 组织信息 CA的信息  有效时间  证书序列号等,这些信息都是明文,同时包含一个CA生成的签名。


* 数字签名: 首先CA使用Hash函数来计算 申请人提交的明文信息,并得出 `信息摘要`,然后CA再使用它的私钥对信息摘要进行加密,加密后的密文就是CA颁给申请人的数字签名。

# 浏览器如何验证数字证书

* 浏览器接收到数字证书之后,会对数字证书进行验证。首先浏览器读取证书中相关的明文信息,采用CA签名时相同的Hash函数来计算并得到 信息摘要A 然后再利用对应CA的公钥解密签名数据,得到 信息摘要B。如果一致就可以确认证书是合法的。同时浏览器还会验证证书相关的域名信息 有效时间等信息。

* 通常情况下,操作系统中会内置信任的顶级CA的证书信息(包含公钥),如果这个CA链中没有找到浏览器内置的顶级的CA,证书也会被判定非法。

* 申请和使用证书的过程中,需要注意一下三点:
1. 申请数据证书是不需要提供私钥的,要确保私钥永远只能由服务器掌握
2. 数字证书最核心的是CA使用它的私钥生成的数字签名
3. 内置CA对应的证书称为根证书,根证书是最权威的机构,它们自己为自己签名,我们把这称为自签名书。