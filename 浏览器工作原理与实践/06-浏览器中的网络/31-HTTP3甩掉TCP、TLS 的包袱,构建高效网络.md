
* HTTP/2
1. [HTTP/2 与 WEB 性能优化(一)](https://imququ.com/post/http2-and-wpo-1.html)
2. [HTTP/2 与 WEB 性能优化(二)](https://imququ.com/post/http2-and-wpo-2.html)
3. [HTTP/2 与 WEB 性能优化(三)](https://imququ.com/post/http2-and-wpo-3.html)


* HTTP/2的一个核心特性时使用了多路复用技术,因此它可以通过一个TCP连接来发送多个URL请求。多路复用技术能充分利用带宽,最大限度规避了TCP的慢启动所带来的问题,同时还是实现了头部压缩、服务端推送等功能,使得页面资源的传输速度得到了大幅提升。


* HTTP/2缺陷

# TCP的队头阻塞
* 虽然HTTP/2解决了应用层面的队头阻塞问题,不过和HTTP/1.1一样,HTTP/2依然是基于TCP协议的,而TCP最初就是为了单连接而设计的。可以把TCP连接看成是两台计算机之前的一个虚拟通道,计算机的一端将要传输的数据按照顺序放入管道,最终数据会以相同的顺序出现在管道的另外一头。
![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%20TCP%20%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B.png)

* 通过上图会发现,从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包,这些数据包通过网络传输到了接收端,接收端再按照顺序将这些数据包组合成原始数据,这样就完成了数据传输。

* 不过,如果在数据传输的过程中,有一个数据因为网络故障或者其他原因而丢包了,那么整个TCP的连接就会处于暂停的状态,需要等待丢失的数据被重新传输过来。可以把TCP连接看成是一个按照顺序传输数据的管道,管道中任意一个数据丢失了,那之后的数据都需要等待该数据的重新传输。
![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/TCP%E4%B8%A2%E5%8C%85%E7%8A%B6%E6%80%81.png)

* `在TCP传输过程中,由于单个数据包的丢失而造成的阻塞称为TCP上队头阻塞。`

* HTTP/2中,多个请求时跑在一个TCP管道中的,如果其中任意一路数据流中出现了丢包的情况,那么就会阻塞该TCP连接中的所有请求。这不同于HTTP/1.1使用HTTP/1.1时,浏览器为每个域名开启了6个TCP连接,如果其中1个TCP连接发生了队头阻塞,那么其他的5个连接依然可以继续传输数据。

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/HTTP2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)

* 随着丢包率的增加,HTTP/2的传输效率也会越来越差,有测试数据表明,当系统达到了2%的丢包率时,HTTP/1.1的传输效率反而比HTTP/2表现得更好。

# TCP建立连接的延迟
* 除了TCP队头阻塞之外,TCP的握手过程也是影响传输效率的一个重要因素。

* `网络延时`又称为 RTT(Round Trip Time)  我们把从浏览器发送一个数据包到服务器,再从服务器返回数据包到浏览器的整个往返时间称为 RTT。 RTT是反映网络性能的一个重要指标。

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6.png)

* HTTP/1和HTTP/2都是使用TCP协议来传输的,而如果使用HTTPS的话,还需要使用TLS协议进行安全传输,而使用TLS也需要一个握手过程,这样就需要有两个握手延迟过程。

* [跟着动画来学习TCP三次握手和四次挥手](https://juejin.im/post/5b29d2c4e51d4558b80b1d8c)
1. 在建立TCP连接的时候,需要和服务器进行三次握手来确认连接成功,也就是说需要在消耗完1.5个RTT之后才能进行数据传输
2. 进行TLS连接,TLS有两个版本--- TLS1.2 和 TLS1.3 每个版本建立连接所话的时间不同,大致是需要1~2个RTT 

* 总之,在传输数据之前,需要花掉3~4个RTT。如果浏览器和服务器的物理距离较近,那么1个RTT的时间可能在10毫秒以内,也就是说总共要消耗掉30~40毫秒。这个时间也许用户还可以接受,但如果服务器相隔较远,那么1个RTT就有可能需要100毫秒以上了,这种情况下整个握手过程需要300~400毫秒,这时用户就能明显地感受到'慢'了。

# TCP协议僵化

* 知道了TCP协议的队头阻塞和建立连接延迟等缺点,是不是可以通过改进TCP协议来解决这些问题?

* `非常困难`
1. `中间设备的僵化` 互联网是由多个互联网是有多个网络互联的网状结构,为了能够保障互联网的正常工作,我们需要在互联网的各处搭建各种设备,这些设备就被称为中间设备。
* 这些中间设备有很多种类型,并且每种设备都有自己的目的,这些设备包括了路由器 防火墙 NAT 交换机等。它们通常依赖一些很少升级的软件,这些软件使用了大量的TCP特性,这些功能被设置之后就很少更新了。
* 如果我们在客户端升级了TCP协议,但是当新协议的数据包经过这些中间设备时,它们可以不理解包的内容,于是这些数据就会被丢掉。`这就是中间设备僵化,它是阻碍TCP更新的一大障碍。`
* 除了中间设备僵化外,`操作系统也是导致TCP协议僵化的另外一个原因。` 因为TCP协议都是通过操作系统内核来实现的,应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新,因此要想要自由地更新内核中的TCP协议也是非常困难的。

# QUIC协议
* 修改TCP协议是非常困难的,因此，HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为`QUIC协议`
![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/HTTP2%E5%92%8CHTTP3%20%E5%8D%8F%E8%AE%AE%E6%A0%88.png)

* `实现了类似TCP的流量控制、传输可靠性的功能` 虽然UDP不提供可靠性的传输,但QUIC在UDP的基础上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。
* `继承了TLS加密功能。`目前QUIC使用的是TLS1.3 相较于早期版本TLS1.3有更多的优点,其中最重要的一点是减少了握手所花费的RTT个数
* `实现了HTTP/2中多路复用功能。` 和TCP不同 QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输,就解决了TCP中队头阻塞的问题。

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/QUIC%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)

* `实现了快速握手功能` 由于QUIC是基于UDP的,所以QUIC可以实现使用0RTT 或者1 RTT来建立连接,这意味着QUIC可以用最快的速度来发送和接收数据,可以大大提升首次打开页面的速度。

# HTTP/3的挑战

1. 从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。
2. 部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。
3. 中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。