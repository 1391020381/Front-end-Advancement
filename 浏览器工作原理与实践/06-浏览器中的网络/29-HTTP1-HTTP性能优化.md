* HTTP是浏览器中最重要且使用最多的协议,是浏览器和服务器之间的通信语言。
* 即将完成使命的HTTP/1  正在向我们走来的HTTP/2  以及未来的HTTP/3

# 超文本传输协议HTTP/0.9
* HTTP/0.9主要用于学术交流,需要很简单——用来在网络之间传递HTML超文本的内容,所以被称为 超文本传输协议。整体来看,它的需求也很简单,采用了基于请求响应的模式,从客户端发出的请求,服务端返回数据。
1. 因为HTTP都是基于TCP协议的,所以客户端先要根据IP地址、端口号和服务器建立TCP连接,而建立连接的过程就是TCP协议三次握手的过程。
2. 建立好连接之后,会发送一个GET请求行的信息,如GET /index.html用来获取index.html
3. 服务器接收请求信息之后,读取对应的HTML文件,并将数据以ASCII字符流返回给客户端。

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/HTTP0.9%20%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png)

1. 第一个是只有一个请求行,并没有HTTP请求头和请求体,因为只需要一个请求行就可以完整表达客户端的需求了。
2. 第二个是服务器也没有返回头消息,这是因为服务器端并不需要告诉客户端太多的信息,只需要返回数据就可以了。
3. 第三个是返回的文件内容是以ASCII字符流的传输的,因为都是HTML格式的文件,所以使用ASCII字节码来传输是最合适的

# 被浏览器推动的 HTTP/1.0

* 万维网的高速发展带来了很多新的需求,不再在浏览器中单纯展示HTML文件了,还包括了js css 图片  音频 视频  等不同的类型的文件。因此`支持多种类型的文件下载是HTTP/1.O的一个核心诉求` 而且文件格式不仅仅局限于ASCII编码,还有很多其他类型编码的文件。

# 那么该如何实现多种类型文件的下载呢?

* HTTP是浏览器和服务器之间的通信语言,不过HTTP/0.9在建立好连接之后,只会发送类似 GET /index.html的简单请求命令,并没有其他途径告诉服务器更多的信息,如文件编码 文件类型等。同样,服务器是直接返回数据给浏览器的,也没有其他途径告诉浏览器更多的关于服务器返回的文件信息。

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/HTTP1.0%20%E7%9A%84%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png)

# HTTP/1.0是怎么通过请求头和响应头来支持多种不同类型的数据
* 要支持多种类型的文件,我们就需要解决以下几个问题。
1. 首先,浏览器需要知道服务器返回的数据是什么类型,然后浏览器才能根据不同的数据类型做针对性的处理。
2. 其次,由于万维网所支持的应用变的越来越广,所以单个文件的数据量也变的越来越大。为了减轻传输性能,服务器会对数据进行压缩后再传输,所以浏览器需要知道服务器压缩的方法。
3. 再次,由于万维网是支持全球范围的,所以需要提供国际化的支持,服务器需要针对不同的地区提供不同的语言版本,这就需要浏览器告诉服务器它想要什么语言版本的页面
4. 最后,由于增加了各种不同类型的文件,而各种文件的编码形式又可能不一样,为了能准确地读取文件,浏览器需要知道文件的编码类型。


* `基于以上问题,HTTP/1.0的方案是通过请求头和响应头来进行协商,在发起请求时候会通过HTTP请求头告诉服务器它期待服务器返回什么类型的文件 采取什么形式的压缩 提供什么语言的文件以及文件的具体编码`。

```
accept: text/html
accept-encoding: gzip, deflate, br
accept-Charset: ISO-8859-1,utf-8
accept-language: zh-CN,zh


```
* `服务器接收到浏览器发送过来的请求头信息之后,会根据请求头的信息来准备响应数据`。不过有时候会有一些意外情况发生,比如浏览器请求的压缩类型是gzip,但是服务器不支持gzip,只支持br压缩,那么它会通过响应头中的content-encoding字段告诉浏览器最终的压缩类型,也就是说最终浏览器需要根据响应头的信息来处理数据。

```
content-encoding: br
content-type: text/html; charset=UTF-8

```
* 浏览器根据响应头信息,来解析相应的文件。

* HTTP/1.0除了对多文件提供良好的支持外,还引入了其他特性。
1. 有的请求服务器可能无法处理,或者处理出错,这时候就需要告诉浏览器服务器最终的处理该请求的情况,这就引入了 `状态码`。`状态码是通过响应行的方式来告诉浏览器的`
2. 为了减轻服务器的压力,在HTTP/1.0中提供了`Cache机制` 用来缓存已经下载过的数据。
3. 服务器需要统计客户端的基础信息,比如Windows 和macOS的用户数量分别是多少,所以HTTP/1.0的请求头中还加入了`用户代理`的字段。

* 状态码   Cache机制   用户代理


# 缝缝补补的HTTP/1.1

1. 改进持久连接
* HTTP/1.0每进行一次HTTP通信,都需要经历建立TCP连接、传输HTTP数据和断开TCP连接三个阶段(如下图)

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/HTTP1.0%E7%9A%84%E7%9F%AD%E8%BF%9E%E6%8E%A5.png)

* 为了解决在下载每个文件的时候,都需要经历建立TCP连接、传输数据和断开连接这样的步骤。`HTTP/1.1中增加了持久连接的方法,它的特点是在一个TCP连接上可以传输多个HTTP请求,只要浏览器或者服务器没有明确断开连接,那么该TCP连接会一直保持`

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/HTTP1.0%20%E7%9A%84%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png)

* HTTP的持久连接可以有效减少TCP建立连接和断开连接的次数,减少了服务器额外的负担,并提升整体HTTP的请求时长。
* `持久连接在HTTP/1.1是默认开启的` 所以不需要专门为了持久连接出HTTP请求头设置信息,如果不想采用持久连接,可以在HTTP请求头中加入 Connection:close
* `目前浏览器中对于同一个域名,默认允许同时建立6个TCP持久连接`

2. 不成熟的HTTP管线化
* 持久连接虽然能减少TCP的建立和断开次数,但是它需要等待前面的请求返回之后,才能进行下一次请求。
* 如果TCP通道中某个请求因为某些原因没有及时返回,那么就会阻塞后面的所有请求,这就是著名的`队头阻塞`的问题。

* HTTP/1.1中试图通过管线化的技术来解决队头阻塞的问题。`HTTP/1.1中的管线化是指多个HTTP请求整批提交给服务器的技术,虽然可以整体发送请求,不过服务器依然需要根据请求顺序来回复浏览器的请求。`
* FireFox Chrome 都做过管线化的实验,但是由于各种原因,它们最终都放弃了管线化技术。

3. 提供虚拟主机的支持
* 在HTTP/1.0中,每个域名绑定了唯一的IP地址,因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展,需要实现在一台物理主机上绑定多个虚拟主机,每个虚拟主机都有自己的单独的域名,这些单独的域名都公用同一个IP地址
* HTTP/1.1的请求头中增加了`Host字段` 用来表示当前的域名地址,这样服务器就可以根据不同的Host值做不同的处理
4. 对动态生成的内容提供了完美的支持
* 在设计HTTP/1.0时,需要在响应头设置完整的数据大小,如 Content-Length:901 这样浏览器就可以根据设置的数据大小来接受数据。不过随着服务器端的技术发展,很多页面的内容都是动态生成的,因此在传输数据之前并不知道最终的数据大小,这导致了浏览器不知道何时会接受所有的文件数据。
* HTTP/1.1通过引入 `Chunk transfer机制`来解决这个问题,服务器会将数据分割成若干个任意大小的数据块,每个数据块发送时会附上上个数据块的长度,最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。
5. 客户端Cookie 安全机制
* HTTP/1.1还引入了客户端Cookie机制和安全机制。

# 总结
