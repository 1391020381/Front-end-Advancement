
* HTTP/1.1为网络效率做了大量的优化,最核心的有如下三种方式:
1. 增加了持久连接
2. 浏览器为每个域名最多同时维护6个TCP持久连接
3. 使用CDN的实现域名分片机制

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/HTTP1.1%20%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F.png)

* 引入CDN,并同时为每个域名维护6个连接,这样就大大减轻了整个资源的下载时间。这里简单计算如下:如果使用单个TCP的持久连接,下载100个资源所花费的时间为100*n*RTT; 若通过上面的技术,就可以把整个时间缩短为100*n*RTT/(6*CDN个数)

# HTTP/1.1的主要问题

* `HTTP/1.1对带宽的利用效率却并不理想,这也是HTTP/1.1的一个核心问题。`
* `带宽是指每秒最大能发送或者接收的字节数。`我们把每秒能发送的最大字节数称为`上行带宽`,每秒能够接收的最大字节数称为下行带宽。

* 出现HTTP/1.1带宽利用效率不理想的原因:
1. 第一个原因,TCP的慢启动
* 一旦一个TCP连接建立之后,就进入了发送数据状态,刚开始TCP协议会采用一个非常慢的速度去发送数据,然后慢慢加快发送数据的速度,直到发送数据的速度达到一个理想状态,我们把这个过程称为`慢启动`

* 你可以把每个TCP发送数据的过程看成是一辆车的启动过程,当刚进入公路时,会有从0到一个稳定速度的提速过程,TCP的慢启动就类似于该过程。

* `慢启动是TCP为了减少网络拥塞的一种策略,我们没有办法改变的。`
* 而之所以说慢启动会带来性能问题,是因为页面中常用的一些关键资源文件本来就不大,如HTML文件 CSS文件 和 js文件,通常这些文件在TCP连接建立好之后就要发起请求的,但这个过程是慢启动,所以耗费的时间比正常的时间要多很多,这样就推迟了宝贵的首次渲染页面的时长了。

2. 第二个原因, 同时开启了多条TCP连接,那么这些连接会竞争固定的带宽。

* 系统同时建立了多条TCP连接,当带宽充足时,每条连接发送或者接收速度会慢慢向上增加;而一旦带宽不足时,这些TCP连接又会减慢发送或者接收的速度。比如一个页面有200个文件,使用了3个CDN,那么加载该网页的时候就需要建立 6*3,18个TCP连接来下载资源;在下载过程中,当发现带宽不足的时候,各个TCP连接就需要动态减慢接收数据的速度。

* 这样就会出现一个问题,因为有的TCP连接下载的是一些关键资源,如CSS文件、 js文件等,而有的TCP连接下载的是图片 视频等普通的资源文件,但是多条TCP连接之间又不能协商让哪些关键资源有限下载,这样就有可能影响那些关键资源的下载速度了。

3. 第三个原因,HTTP/1.1队头阻塞的问题
* HTTP/1.1持久连接时,虽然公用一个TCP管道,但是在一个管道中同一时刻只能处理一个请求,在当前的请求没有结束之前,其他的请求只能处于阻塞状态。这意味我们不能随意在一个管道中发送请求和接收内容。
* 这是一个很严重的问题,因为阻塞请求的因素有很多,并且都是一些不确定性的因素,假如有的请求被阻塞了5秒,那么后续排队的请求都要延迟等待5秒,在这个等待的过程中,带宽 CPU 都被白白浪费了。

* 在浏览器处理生成页面的过程中,是非常希望能提前接收到数据的,这样就可以对这些数据做预处理操作,比如提前接收到了图片,那么就可以提前进行编解码操作,等到需要使用该图片的时候,就可以直接给出处理后的数据了,这样能让用户感受到整体速度的提升。

* `但队头阻塞使得这些数据不能并行请求,所以队头阻塞是不利于浏览器优化的。`

# HTTP/2的多路复用

* HTTP/1.1存在的主要问题:
1. 慢启动  `慢启动是TCP为了减少网络拥塞的一种策略,我们没有办法改变的。`
2. TCP连接之间相互竞争带宽是由于TCP本身的机制导致的
3. 队头阻塞是由于HTTP/1.1的机制导致的。


* `基于上面的问题,HTTP/2的思路就是一个域名只是用一个TCP长连接来传输数据,这样整个页面资源的下载过程只需要一次慢启动,同时也避免了多个TCP连接竞争带宽所带来的问题。`
* 队头阻塞的问题,等待请求完成后才能出请求下一个资源,这种方式无疑是最慢的,所以HTTP/2.0需要实现资源的并行下载,也就是任何时候都可以将请求发送给服务器,而并不需要等待其他请求的完成,然后服务器也可以随时返回处理好的请求资源给浏览器。

* HTTP/2的解决方案可以总结为:`一个域名只使用一个TCP长连接和消除队头阻塞问题。`

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/HTTP2%20%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)

* `多路复用机制`是HTTP/2最核心最重要最颠覆的东西。
* `每个请求都有一个对应的ID` 如 stream1 表示index.html请求   stream2表示foo.css的请求。这样在浏览器端,就可以随时将请求发送给服务器了。

* 服务器端接收到这些请求后,会根据自己喜好来决定优先返回哪些内容,比如服务器可能早就缓存好了index.html和bar.js的响应头信息,那么当接收到请求的时候就`可以立即把index.html和bar.js的响应头信息返回给浏览器,然后再将index.html和bar.js的响应体数据返回给浏览器。` 
* 之所以可以随意发送,是因为每份数据都有对应的ID,浏览器接收到之后,会晒选出相同ID的内容,将其拼接为完整的HTTP响应数据。

* HTTP/2使用了多路复用技术,可以将请求分成一帧一帧的数据去传输,这样带来了一个额外的好处,就是`当接收到一个优先级高的请求时`,比如接收到js css关键资源的请求,服务器可以暂停之前的请求来优先处理关键资源的请求。

# 多路复用的实现

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/HTTP2%20%E5%8D%8F%E8%AE%AE%E6%A0%88.png)

* HTTP/2添加了一个`二进制分帧层`
1. 首先,浏览器准备好请求数据 包括了请求行 请求头等信息,如果是POST方法,那么还要有请求体。
2. 这些数据经过二进制分帧层处理之后,会被转换为一个个带有请求ID编号的帧,通过协议栈将这些帧发送给了服务器。
3. 服务器接收到所有帧之后,会将所有相同的ID编号的的帧合并为一条完整的请求信息。
4. 然后服务器处理该请求,并将处理的响应行 响应头和响应体分别发送至二进制分帧层。
5. 同样,二进制分帧层将会这些响应数据转换为一个个带有请求ID编号的帧,经过协议发送给浏览器。
6. 浏览器接收到响应帧之后,会根据ID编号将帧的数据提交给对应的请求。

* `通过引入二进制分帧层,就实现了HTTP的多路复用技术`
* HTTP是浏览器和服务器通信的语言,虽然HTTP/2引入了二进制分帧层,不过HTTP/2的语义和HTTP/1.1依然是一样的。(请求头的一些含义,与HTTP/1.1是保持一致的)

# HTTP/2其他特性

1. 可以设置请求的优先级

* HTTP/2提供了请求优先级,可以在发送请求时,标上请求的优先级,这样服务器接收到请求之后,会优先处理优先级高的请求。

2. 服务端推送
* HTTP/2可以直接将数据提前推送到浏览器。
3. 头部压缩
* HTTP/2对请求头和响应头进行了压缩。 在浏览器发送请求的时候,基本上都是发送HTTP请求头,很少有请求体的发送,通常情况下页面也有100个左右的资源,如果将这100个请求头的数据压缩为原来的20%,那么传输效率肯定能得到大幅提升。


# 总结

* 影响HTTP/1.1效率的三个主要因素:TCP的慢启动  多条TCP连接竞争带宽    队头阻塞。
* HTTP/2采用多路复用机制来解决这些问题。多路复用是通过协议栈中添加二进制分帧层来实现的,有了二进制分帧层还能实现请求的优先级  服务端推送  头部压缩等特性,从而大大提升了文件传输效率。
* 使用HTTP/2能带来20%~60%的效率提升,至于20%还是60%要看优化程度。