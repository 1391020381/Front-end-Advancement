* 正是由于JavaScript存在变量提升这种特性,从而导致了很多与直觉不符的代码,这也是JavaScript的一个重要设计缺陷。

# 作用域(Scope)
* 作用域是指在程序中定义变量的区域,该位置决定了变量的生命周期。通俗地理解,作用域就是变量与函数的可访问范围,即作用域控制着变量和函数的可见性和生命周期。

* 在ES6之前,ES的作用域只有两种:全局作用域和函数作用域
- 1. 全局作用域中的对象在代码中的任何地方都能访问,其生命周期伴随着页面的生命周期。
- 2. 函数作用域就是在函数内部定义的变量或者函数,并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后,函数内部定义的变量会被销毁。
- 3. 块级作用域就是使用一对大括号包裹的一段代码,比如函数、判断语句、顺环语句,甚至单独的一个 {} 都可以被看作是一个块级作用域。

```
//if 块
if(1){}

//while 块
while(1){}

// 函数块
function foo(){
 
//for 循环块
for(let i = 0; i<100; i++){}

// 单独一个块
{}


```
* 简单来讲,如果一种语言支持块级作用域,那么其代码内部定义的变量在代码外部时访问不到的。并且等该代码块状元红的代码执行完成之后,代码块定义的变量会被销毁。
# 变量提升带来的问题
1. 变量容易在不被察觉的情况下被覆盖掉

```
var myname = " 极客时间 "
function showName(){
  console.log(myname);
  if(0){
   var myname = " 极客邦 "
  }
  console.log(myname);
}
showName()



```
2. 本应销毁的变量没有被销毁
```

function foo(){
  for (var i = 0; i < 7; i++) {
  }
  console.log(i); 
}
foo()


```

# ES6是如何解决变量提升带来的缺陷
* ES6引入 let 和 const 关键字

# javaScript是如何支持块级作用域的
* `在同一段代码中,ES6是如何做到既要支持变量提升的特性,又要支持块级作用域的`
```
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()


```
![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/浏览器工作原理与实践/note/img/刚执行时%20foo%20函数的执行上下文.png)

* 函数内部通过var声明的变量,在编译阶段全都被放到`变量环境`里面了
* 通过let 声明的变量,在编译阶段会被存放到`词法环境(Lexical Environment)`中
* 在函数的作用域内部,通过 let 声明的变量并没有被存放到词法环境中。

![](https://github.com/1391020381/Front-end-Advancement/blob/浏览器工作原理与实践/note/img/执行%20foo%20函数内部作用域块时的执行上下文.png?raw=true)

* 当进入函数的作用域块时,作用域块中通过let声明的变量,会被存放到词法环境的一个独立的区域中，这个区域中的变量并不影响作用域外面的变量,比如在作用域外面声明了变量b，在该作用域内部也声明变量b，当执行到作用域内部时,它们都是独立的存在。
* `其实,在词法环境内部,维护了一个小型的栈结构,栈低是函数最外层的变量,进入一个作用域块后,就会把该作用域内部的变量压到栈顶;当作用域执行完成之后,该作用域的信息就会从栈顶弹出,这就是词法环境的结构。` 需要注意下,这里讲的是变量通过let const 声明。

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/note/img/%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.png)

![](https://raw.githubusercontent.com/1391020381/Front-end-Advancement/浏览器工作原理与实践/note/img/作用域执行完成示意图.png)

* 块级作用域就是通过词法环境的栈结构来实现的,而变量提升是通过变量换来实现的，通过这两者的结合,javascript引擎也就同时支持了变量提升和块级作用域了。

# 总结



```
let myname= '极客时间'
{
  console.log(myname) 
  let myname= '极客邦'
}



```

* 在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。
* var的创建和初始化被提升，赋值不会被提升。
* let的创建被提升，初始化和赋值不会被提升。
* function的创建、初始化和赋值均会被提升。

* 执行函数时才有进行编译，抽象语法树(AST）在进入函数阶段就生成了，并且函数内部作用域是已经明确了，所以进入块级作用域不会有编译过程，只不过通过let或者const声明的变量会在进入块级作用域的时被创建，但是在该变量没有赋值之前，引用该变量JavaScript引擎会抛出错误---这就是“暂时性死区”
* 函数只会在第一次执行的时候被编译，所以编译时变量环境和词法环境最顶层数据已经确定了。当执行到块级作用域的时候，块级作用域中通过let和const申明的变量会被追加到词法环境中，当这个块执行结束之后，追加到词法作用域的内容又会销毁掉。