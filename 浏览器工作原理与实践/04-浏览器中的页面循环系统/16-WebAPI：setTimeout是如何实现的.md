* `浏览器页面是由消息队列和事件循环系统来驱动的`

* 通过setTimeout 和XMLHttpRequest这两个WebAPI来介绍事件循环的应用。
* setTimeout 一个定时器,用来指定某个函数在多少毫秒之后执行。它返回一个整数,表示定时器的编号,同时可以通过该编号来取消这个定时器。

```
function showName () {
  console.log('极客时间')
}

var timerID = setTimeout(showNanme,200)

```
# 浏览器怎么实现setTimeout
* 渲染引擎中所有运行在主线程上的任务都需要先添加到消息队列,然后事件循环系统再按照顺序执行消息队列中的任务。
- * 当接收到HTML文档数据,渲染引擎就会将'解析DOM事件添加到消息队列中'
- * 当用户改变了Web页面的窗口大小,渲染引擎就会将'重新布局'的事件添加到消息队列中
- * 当触发了js引擎垃圾回收机制,渲染引擎会将'垃圾回收'任务添加到消息队列中
- * 同样,如果要执行一段异步js代码,也是需要将执行任务添加到消息队列中。

* `事件被添加到消息队列之后,事件循环系统就会按照消息队列中的顺序来执行事件。`

* 通过定时器设置回调函数有点特点,它们需要在指定的时间间隔内被调用,但是消息队列中的任务是按照顺序执行的,所以为了保证回调函数能在指定时间内执行,你不能将定时器的回调函数直接添加到消息队列中。

* `在Chrome中除了正常使用的消息队列之外,还有另外一个消息队列,这个消息队列中维护了需要延迟执行的任务列表,包括了定时器和Chromium内部一些需要延迟执行的任务。`所以当通过js创建一个定时器时,渲染进程会将该定时器的回调任务添加到延迟队列中。

# 使用setTimeout的一些事项
1. 如果当前任务执行时间过久,会影响延迟到期定时器任务的执行。

```

function bar() {
    console.log('bar')
}
function foo() {
    setTimeout(bar, 0);
    for (let i = 0; i < 5000; i++) {
        let i = 5+8+8+8
        console.log(i)
    }
}
foo()


```
* 通过setTimeout设置的回调任务被放入了消息队列中并且等待下一次执行,`这里并不是立即执行的;要执行消息队列中的写个任务,需要等待当前的任务执行完成。`由于当前这段代码要执行5000次的for循环,所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。

2. 如果 setTimeout存在嵌套调用,那么系统会设置最短时间间隔为4毫秒

```
function cb() {
  setTimeout(cb,0)
}

setTimeout(cb,0)

```

3. 未激活的页面,setTimeout执行最小间隔是1000毫秒
* 未被激活的页面中定时器最小值大于1000毫秒,也就是说,如果标签不是当前的激活标签,那么定时器最小的时间间隔是1000毫秒,目的是为了优化后台页面的加载损耗以及降低耗电量。

4. 延迟执行时间有最大值
* Chrome Safari Firefox都是以32个bit来存储延时器值的,32bit最大只能存放的数字时是2147483647毫秒,这就意味着,如果setTimeout设置的延迟值大于2147483647毫秒(大约24.8天)时就会溢出,`这导致定时器会被立即执行`。

```
function showName(){
  console.log(" 极客时间 ")
}
var timerID = setTimeout(showName,2147483648);// 会被理解调用执行


```
5. 使用setTimeout设置的回调函数中的this不符合直觉

```
var name = 1;
var MyObj = {
  name:2,
  showName:function(){
    console.log(this.name)
  }
}

setTimeout(MyObj.showName,1000)

```
* 使用 箭头函数
* 使用 bind方法

# 总结

* 首先,为了支持定时器的实现,浏览器增加了`延迟队列`
* 其次,由于消息队列和一些系统级别的限制,通过setTimeout设置的回调任务并非总是可以实时地被执行,这样就不能满足一些实时性要求较高的需求了
* 最后,在定时器使用的过程中,还存在一些陷阱。


* 延迟队列 其实是一个hashmap结构，等到执行这个结构的时候，会计算hashmap中的每个任务是否到期了，到期了就去执行，直到所有到期的任务都执行结束，才会进入下一轮循环！